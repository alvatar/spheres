<html lang="en">
<head>
<title>silex semantics rules - Libraries for Vicare Scheme</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="Libraries for Vicare Scheme">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="silex-semantics.html#silex-semantics" title="silex semantics">
<link rel="prev" href="silex-semantics-action.html#silex-semantics-action" title="silex semantics action">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
This document describes the libraries distributed along with version
0.3d7 of Vicare Scheme, an R6RS compliant native
compiler for the Scheme language.

Copyright (C) 2010-2013 by Marco Maggi.

Copyright (C) 2006-2010 by Abdulaziz Ghuloum.

The documentation of IrRegex is Copyright (C) 2005-2012 Alex
Shinn.  All rights reserved.

The documentation of Pregexp is Copyright (C) 1999-2005 Dorai
Sitaram.  All rights reserved.

The documentation of the library `(vicare formations)' is derived
from the documentation of Guile.  Copyright (C) 1996-2005,
2009-2013 Free Software Foundation.

The documentation of the libraries `(vicare parser-tools silex
---)' are derived form the documentation of SILex.  Copyright
(C) 2001, 2009 Danny Dube'.

     This program is free software: you can redistribute it and/or
     modify it under the terms of the GNU General Public License
     version 3 as published by the Free Software Foundation.

     This program is distributed in the hope that it will be useful, but
     WITHOUT ANY WARRANTY; without even the implied warranty of
     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
     General Public License for more details.

     You should have received a copy of the GNU General Public License
     along with this program.  If not, see
     `http://www.gnu.org/licenses/'.

Trademarks used herein are the property of their respective owners.-->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="silex-semantics-rules"></a>
<p>
Previous:&nbsp;<a rel="previous" accesskey="p" href="silex-semantics-action.html#silex-semantics-action">silex semantics action</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="silex-semantics.html#silex-semantics">silex semantics</a>
<hr>
</div>

<h4 class="subsection">36.6.2 Matching the rules</h4>

<p>All lexical analysers generated by SILex are interactive.  That is, they
read as few characters as possible to get the longest match.  This is a
useful property when the input is coming from a terminal.  A lexical
analyser is normally based on a finite automaton; it is the case for the
analysers generated by SILex.  A non&ndash;interactive analyser always needs
an extra character to provoke an invalid transition in the automaton. 
The longest match is detected this way.  With an interactive analyser,
an extra character is not required when it is impossible to obtain a
longer match.

   <p>A lexical analyser generated by SILex does not impose any <em>a
priori</em> limit on the size of the lexemes.  The internal buffer is
extended each time it is necessary.

   <p>Each time the analyser is asked to return a token, it tries to match a
prefix of the input with a pattern.  There may be more than one possible
match; when it is the case, we say there is a conflict.  For example,
suppose we have those regular expressions:

<pre class="example">     begin
     [a-z]*
</pre>
   <p class="noindent">and the input is &lsquo;<samp><span class="samp">beginning1 ...</span></samp>&rsquo;.  We have a match with
the first expression and we have many different matches with the second. 
To resolve such a conflict, the longest match is chosen.  So the chosen
match is the one between the lexeme &lsquo;<samp><span class="samp">beginning</span></samp>&rsquo; and the second
pattern.

   <p>Suppose we have the same regular expressions but the input is
&lsquo;<samp><span class="samp">begin+ ...</span></samp>&rsquo;.  We have <em>two</em> longest match.  This
conflict is resolved by choosing the first pattern that allows a longest
match.  So the chosen match is between the lexeme &lsquo;<samp><span class="samp">begin</span></samp>&rsquo; and the
first pattern.

   <p>The analyser generated by SILex allows the empty lexeme to be matched if
there is no longer match.  However, we should take care not to call the
analyser again without consuming at least one character of the input: it
would cause an infinite loop.

   <p>The pattern &lsquo;<samp><span class="samp">&lt;&lt;EOF&gt;&gt;</span></samp>&rsquo; is matched when the analyser is called and
the input system is at end of input.  In this situation, the marker is
matched even if there is a pattern that matches the empty lexeme.  The
analyser can be called again and again and the &lsquo;<samp><span class="samp">&lt;&lt;EOF&gt;&gt;</span></samp>&rsquo; pattern
will be matched each time, causing its corresponding action to be
evaluated each time, too.

   <p>The pattern &lsquo;<samp><span class="samp">&lt;&lt;ERROR&gt;&gt;</span></samp>&rsquo; is matched when the input system is not at
end of input and no other match is possible.  Depending on the action
associated with this pattern, our program may choose to stop or choose
to try to recover from the error.  To recover from the error, our
program has to read some characters from the input before it can call
the analyser again.

   <p>As example of error recovery consider the following code which just
shows the mechanism:

<pre class="example">     #!r6rs
     (import (nausicaa)
       (prefix (nausicaa parser-tools lexical-tokens) lt.)
       (prefix (vicare parser-tools silex) lex.)
       (prefix (vicare parser-tools silex lexer) lex.))
     
     (define description "%%
     A          (lt.&lt;lexical-token&gt;
                  ((lt.category: 'A)
                   (lt.location: (lt.&lt;source-location&gt;
                                   ((lt.input:  #f)
                                    (lt.line:   yyline)
                                    (lt.column: yycolumn)
                                    (lt.offset: yyoffset))))
                   (lt.value:    yytext)
                   (lt.length:   (string-length yytext))))
     
     &lt;&lt;EOF&gt;&gt;    (lt.&lt;lexical-token&gt;
                  ((lt.category: '*eoi*)
                   (lt.location: (lt.&lt;source-location&gt;
                                   ((lt.input:  #f)
                                    (lt.line:   yyline)
                                    (lt.column: yycolumn)
                                    (lt.offset: yyoffset))))
                   (lt.value:    (eof-object))
                   (lt.length:   1)))
     
     &lt;&lt;ERROR&gt;&gt;  (lt.&lt;lexical-token&gt;
                  ((lt.category: '*lexer-error*)
                   (lt.location: (lt.&lt;source-location&gt;
                                   ((lt.input:  #f)
                                    (lt.line:   yyline)
                                    (lt.column: yycolumn)
                                    (lt.offset: yyoffset))))
                   (lt.value:    yytext)
                   (lt.length:   (string-length yytext))))
     ")
     
     (define table
       (lex.lex
         (lex.input-string:     description)
         (lex.counters:         'all)
         (lex.library-language: '(vicare))
         (lex.library-imports:
           '((prefix (nausicaa parser-tools lexical-token) lt.)))
         (lex.output-value:     #t)
         (lex.lexer-format:     'decision-tree)))
     
     ;; correct string
     (let* ((IS    (lex.make-IS
                     (lex.string: "AAA")
                     (lex.counters: 'all)))
            (lexer (lex.make-lexer table IS)))
       (let (((T1 lt.&lt;lexical-token&gt;) (lexer))
             ((T2 lt.&lt;lexical-token&gt;) (lexer))
             ((T3 lt.&lt;lexical-token&gt;) (lexer))
             ((T4 lt.&lt;lexical-token&gt;) (lexer)))
         (list (T1 category) (T2 category)
               (T3 category) (T4 category))))
     &rArr; (A A A *eoi*)
     
     ;; lexer error
     (let* ((IS    (lex.make-IS
                     (lex.string: "AAAB")
                     (lex.counters: 'all)))
            (lexer (lex.make-lexer table IS)))
       (let (((T1 lt.&lt;lexical-token&gt;) (lexer))
             ((T2 lt.&lt;lexical-token&gt;) (lexer))
             ((T3 lt.&lt;lexical-token&gt;) (lexer))
             ((T4 lt.&lt;lexical-token&gt;) (lexer)))
         (list (T1 category) (T2 category)
               (T3 category) (T4 category))))
     &rArr; (A A A *lexer-error*)
     
     ;; lexer error and recovery
     (let* ((IS    (lex.make-IS
                     (lex.string: "AAABBAA")
                     (lex.counters: 'all)))
            (lexer (lex.make-lexer table IS)))
       (let (((T1 lt.&lt;lexical-token&gt;) (lexer))
             ((T2 lt.&lt;lexical-token&gt;) (lexer))
             ((T3 lt.&lt;lexical-token&gt;) (lexer))
             ((T4 lt.&lt;lexical-token&gt;) (lexer)))
         ;; discard invalid characters,
         ;; we know there are 2 of them
         (let ((getc (lex.lexer-get-func-getc IS)))
           (getc)
           (getc))
         (let (((T5 lt.&lt;lexical-token&gt;) (lexer))
               ((T6 lt.&lt;lexical-token&gt;) (lexer))
               ((T7 lt.&lt;lexical-token&gt;) (lexer)))
           (list (T1 category) (T2 category) (T3 category)
                 (T4 category)
                 (T5 category) (T6 category) (T7 category)))))
     &rArr; (A A A *lexer-error* A A *eoi*)
</pre>
   <!-- page -->
   </body></html>

