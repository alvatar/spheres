;; HTTP FORM POST multipart/form-data format data decoder library
;; For use with the Sack web middleware
;; Copyright (C) 2010, 2013 Mikael More. MIT license.
;;
;; This format is the preferred one for HTTP POST-based file uploads, from HTML FORM:s and similar technologies.
;;
;; Overlaps a sack-app and provides it with a 'form:data environment parameter.
;; Example:
;;
;; (sack-start! (multipart/form-data-form-post->
;;                (lambda (env)
;;                  (env 'form:data)
;;                  ..
;;                  )))
;;
;; For doing invocations manually, you can use (multipart/form-data-form-post-get env) => form-data .
;;
;; form-data is the MIME-decoded content, as generated by |mime-decode-multipart-with-boundary| in the mime module.
;;
;; The decoding procedure used internally is
;; (multipart/form-data-form-post-decode content-type-s get-post-data-s) => form-data .
;; It invokes the get-post-data-s argument at first if the content-type-s has been found to be
;; multipart/form-data , so we don't waste CPU resources on reading out the post-data without need.
;;
;; This module delivers the received form data values in the form of u8vectors, and can therefore be
;; said to be pretty character encoding-agnostic. (Keys use to be in ascii anyhow.)
;;
;; Essentially what this library does is to step through the mime-encoded form data sent to this library,
;; and pass each chunk through the mime library for decoding using the mime-decode-multipart-with-boundary
;; procedure.
;;
;; For extraction of from |form-data| of uploaded files, the following conveniency procedures are provided:
;;
;; (form-data-extract-uploaded-files form-data) => list of list (form-field-name filename sender-content-type data-u8v)
;; (form-data-extract-uploaded-file form-data) = Same as form-data-extract-uploaded-files but returns only first file,
;;                                               or #f if there's no file.
;; (with-form-data-extract-uploaded-file form-data . code) = Loads the variables form-field-name filename data-u8v into
;;                                                           the local namespace.
;;
;; ## History
;; 2013-07-29: Added multipart/form-data-verbose? variable and added more debug output for more easily tracking
;;             broken input.
;;
;; ## TODO
;;  * |multipart/form-data-form-post-decode| is written in a weird way so that the form data becomes available
;;    at first during the sack-app's output procedure invocations. This is a completely unnecessary postponement
;;    and the code can equally well be restructured so that it's available already on the initial sack-app-thunk
;;    invocation. This is easy to implement, just do it as soon as of use.
;;  * Implement a max input size constraint, so that we're not susceptible to heap overflow from malevolent user.
;;

(declare (block) (standard-bindings) (extended-bindings) (mostly-fixnum))

(define filter
  (lambda (p s)
    (cond
     ((null? s) '())
     ((p (car s)) (cons (car s) (filter p (cdr s))))
     (else (filter p (cdr s))))))



(define multipart/form-data-verbose? #f)
(set! multipart/form-data-verbose? #f)

(define console-output-port (current-output-port))

(define-macro (m/fd-dbg . a)
  `(if multipart/form-data-verbose?
       (begin
         (print port: console-output-port "multipart/form-data: " ,@a "\n")
         (force-output console-output-port))))

(define (u8vector-ensure-ends-by-cr-lf u8v)
  (let ((l (u8vector-length u8v)))
    (if (or (< l 2)
            (not (eq? 13 (u8vector-ref u8v (- l 2))))
            (not (eq? 10 (u8vector-ref u8v (- l 1)))))
        (u8vector-append u8v '#u8(13 10))
        u8v)))

(define (multipart/form-data-form-post-decode content-type-s get-post-data-s)
  ;; Confirm multipart/form-data content-type
  (let ((parts (string-split-char #\; content-type-s)))
    (cond ((not (>= (length parts) 2))
           (m/fd-dbg "content-type contains no semicolon (;) . At least one semicolon is required for the inlining of the boundary setting. Returning #f.")
           #f)
          ((not (equal? "multipart/form-data" (car parts)))
           (m/fd-dbg "The content-type does not regard multipart/form-data. Returning #f.")
           #f)
          (else
           ;; Extract boundary string parameter (compulsory)
           (let* ((args (map
                         (lambda (v)
                           (or (let ((v (string-split-at-first-nice #\= v)))
                                 (set-car! v (string-trim (car v) #\space))
                                 v)
                               (cons #f #f)))
                         (cdr parts)))
                  (boundary (assoc "boundary" args)))
             (m/fd-dbg "args=" args " boundary=" boundary)
             (and boundary
                  (let* ((boundary (cdr boundary))
                         ;; Perform MIME document decode on the post data string given the boundary
                         (request-body (get-post-data-s))
                         (request-body (u8vector-ensure-ends-by-cr-lf request-body))
                         (form-data    (mime-decode-multipart-with-boundary
                                        request-body 0 (u8vector-length request-body) boundary
                                        #t ; = all-as-u8vector
                                        )))
                    (m/fd-dbg "form-post: Successfully parsed.\n")
                    (m/fd-dbg "Input: request-body: " request-body " boundary: " boundary)
                    (m/fd-dbg "Output: " form-data)
                    form-data)))))))

(define (multipart/form-data-form-post-get env)
  (let ((content-type ((env 'sack:headers) "content-type")))
    (if (null? content-type)
        (begin
          (m/fd-dbg "Got no content-type, so returning #f.")
          #f)
        (let* ((content-type (car content-type)))
          (multipart/form-data-form-post-decode
           content-type
           (lambda ()
             (let ((p (open-output-u8vector))
                   (buf (make-string 10240)))
               ((env 'sack:body) (lambda (chunk)
                                   ;; (dbg "form-post-decode data handler received from client u8vector packet: " chunk)
                                   (write-subu8vector chunk 0 (u8vector-length chunk) p)))
               (let ((v (get-output-u8vector p)))
                 (close-port p)
                 (set! buf #f)
                 (m/fd-dbg "Read " (u8vector-length v) " bytes input.")
                 (m/fd-dbg "form-post-decode transfer data handler received from client: " v)
                 v))))))))

(define (multipart/form-data-form-post-wrapper env thunk)
  ;; (print port: console-output-port "form-post: Into. Thread=#" (object->serial-number (current-thread)) "\n")
  (let* ((goto-output-proc #f)
         (form-data #f)
         (got-form-data? #f)
         (get-form-data
          (lambda ()
            (if got-form-data?
                form-data
                (begin
                  (set! got-form-data? #t)
                  (set! form-data (multipart/form-data-form-post-get env))
                  form-data))))
         (env (lambda a
                (if (equal? a '(form:data))
                    (get-form-data)
                    (apply env a)))))
    (thunk env)))

(define (multipart/form-data-form-post-> thunk)
  (lambda (env)
    (multipart/form-data-form-post-wrapper env thunk)))

;; => list of list (form-field-name filename sender-content-type data-u8v)
(define (form-data-extract-uploaded-files form-data)
  ;; If form-data parsing did not work out, then we got no files.
  (if (not form-data)
      '()
      ;; form-data parsing did work out; go through its output and take out the files.
      (filter (lambda (v) v)                 ; = set?
              (map (lambda (mime-data-section)
                     (let ((headers (car mime-data-section))
                           (value   (cdr mime-data-section)))
                       ;; The key information we're looking for now is the Content-Disposition header.
                       ;; By parsing it, we will know if we're on a filename now.
                       (let headers-loop ((rest headers))
                         (if (null? rest)
                             #f ; Did not find a Content-Disposition header - so this is not a file.
                             (let ((header (car rest)) (rest (cdr rest)))
                               (if (not (eq? (car  header) 'content-disposition))
                                   ;; This was not a Content-Disposition header; keep scanning.
                                   (headers-loop rest)
                                   ;; This is the Content-Disposition header. Parse it.
                                   (if (not (eq? (cadr header) 'form-data))
                                       ;; This was not a form-data Content-Disposition header, and can thus not be
                                       ;; a form file upload - so this is not a file.
                                       #f
                                       ;; So we got a form-data Content-Disposition header.
                                       ;; Now process it as to see if it's a file upload.
                                       (let ((form-field-name     #f)
                                             (filename            #f)
                                             (sender-content-type #f))
                                         (for-each (lambda (e)
                                                     (let ((key (car e)) (value (cdr e)))
                                                       (case key
                                                         ((name        ) (set! form-field-name     value))
                                                         ((filename    ) (set! filename            value))
                                                         ((content-type) (set! sender-content-type value))
                                                         ;; Other ignore.
                                                         )))
                                                   (cddr header))
                                         ;; Basically if we got the filename we know it's a file. Every form value MIME section
                                         ;; should have a field name also, so we require this too.
                                         (if (not (and form-field-name filename))
                                             #f ; Was not a file upload.
                                             ;; We got a file upload! :)
                                             (let ((data-u8v value))
                                               (list form-field-name filename sender-content-type data-u8v)))))))))))
                   form-data))))

(define (form-data-extract-uploaded-file form-data)
  (let ((v (form-data-extract-uploaded-files form-data)))
    (and (not (null? v)) (car v))))

